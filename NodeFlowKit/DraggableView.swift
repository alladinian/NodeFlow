//
//  DraggableView.swift
//  NodeFlowKit
//
//  Created by Vasilis Akoinoglou on 20/12/2018.
//  Copyright Â© 2018 Vasilis Akoinoglou. All rights reserved.
//

import Cocoa

class DraggableView: NSView {
    var location: NSPoint         = .zero
    var dragging: Bool            = false
    var lastDragLocation: NSPoint = .zero

    override init(frame frameRect: NSRect) {
        super.init(frame: frameRect)
    }

    required init?(coder decoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }

    override var isOpaque: Bool { return true }

    var calculatedItemBounds: CGRect {
        // calculate the bounds of the draggable item
        // relative to the location
        return CGRect(origin: location, size: bounds.size)
    }

    func offsetLocationBy(x: CGFloat, y: CGFloat) {
        // tell the display to redraw the old rect
        setNeedsDisplay(calculatedItemBounds)
        // since the offset can be generated by both mouse moves
        // and moveUp:, moveDown:, etc.. actions, we'll invert
        // the deltaY amount based on if the view is flipped or
        // not.
        let invertDeltaY = isFlipped ? -1 : 1
        location.x = location.x + x
        location.y = location.y + y * CGFloat(invertDeltaY)

        // invalidate the new rect location so that it'll
        // be redrawn
        setNeedsDisplay(calculatedItemBounds)
    }

    func isPointInItem(_ point: NSPoint) -> Bool {
        return NSPointInRect(point, calculatedItemBounds)
    }

    override func mouseDown(with event: NSEvent) {
        let clickLocation = convert(event.locationInWindow, from: nil)
        guard isPointInItem(clickLocation) else { return }
        dragging = true
        lastDragLocation = clickLocation
        NSCursor.closedHand.push()
    }

    override func mouseDragged(with event: NSEvent) {
        guard dragging else { return }
        let newDragLocation = convert(event.locationInWindow, from: nil)
        offsetLocationBy(x: newDragLocation.x - lastDragLocation.x, y: newDragLocation.y - lastDragLocation.y)
        lastDragLocation = newDragLocation
        autoscroll(with: event)
    }

    override func mouseUp(with event: NSEvent) {
        dragging = false
        NSCursor.pop()
        window?.invalidateCursorRects(for: self)
    }

    override var acceptsFirstResponder: Bool {
        return true
    }

    override func draw(_ dirtyRect: NSRect) {
        NSColor.white.set()
        NSBezierPath.fill(dirtyRect)
    }

    override func resetCursorRects() {
        discardCursorRects()
        addCursorRect(calculatedItemBounds, cursor: NSCursor.openHand)
    }

}
